/*
本文件为Beyond RPC客户端默认配置文件。
用户可以在自己的工程中自定义bsoa.json进行默认配置覆盖。
PS:大家也看到了，本JSON文档是支持注释的，而标准JSOB是不支持的，这属于宽松的的json格式哦！
*/
{
//  "app.id" : null,
//  "app.name": null,
//  "instance.id" : null,
  "bsoa.config.order" : 10,

//  "system.cpu.cores" : 0, // 0代表自动判断，也可以自定义注入，或者启动参数注入

  // 默认连注册中心的超时时间
//  "serialize.check.class":	false,//	序列化时是否检查父子类（声明参数和传入值是父子类）	boolean	默认true，如果业务不存在这种情况可以配置为false，提高性能	1.0.0
//  "transport.consumer.epoll"	:false,//	客户端是否使用epoll（针对linux）	boolean	默认false，Linux开启epoll可提高性能	1.0.3
//  "counter.batch"	:false	,//计数器服务调用步长	int	默认1，每次丢调用计数器，调大可以提高性能但会减低精准	1.2.0
//  "json.serialize.fill.empty" 	:false	,//json序列化是否返回null字段。	boolean	默认false，默认只返回有属性的字段。打开会降低效率。	1.5.1
//  "consumer.provider.nullable":	false,//	consumer的服务端列表是否可被清空	boolean	默认false，默认不能被清空（最后的清空请求被忽略），防止删全部节点等误操作，但是会影响列表的准确性。	1.6.0
//  "invoke.send.app":	false,//	Consumer调用时是否发生信息	boolean	默认true，服务端拿到调用端的自动部署应用信息。配为false，服务端拿不到调用者信息	1.6.0
//  "serialize.check.reference"	:false,//	序列化是否检测循环引用类型	string	默认true，针对c++等调用者进行关闭	1.6.0
//  "json.serializer.features":	false,//	json序列化的时候，开启的特性	string	默认空，参见com.jd.fastjson.serializer.SerializerFeature，多个逗号分隔	1.6.0
//  "json.parser.features":	false,//	json解析的时候，开启的特性	string	默认空，参见com.jd.fastjson.parser.Feature，多个逗号分隔	1.6.0

//  "consumer.share.reconnect.thread" : false, //是否所有客户端共享一个重连线程

//  "default.tags" : "bsoa",
  "default.protocol" : "jsf",
  "default.serialization" : "hessian",
//  "default.compress" : "snappy",
//  "default.proxy" : "javassist",
//  "default.charset" : "UTF-8",
//  "default.transport" : "netty4",


  //  ==============配置相关============
//  "registry.connect.timeout" : 20000,   /* 默认连注册中心的超时时间*/
//  "registry.disconnect.timeout" : 10000, // 注册中心等待结果的超时时间
//  "registry.invoke.timeout" : 10000, // 注册中心调用超时时间
//  "registry.heartbeat.period" : 30000, // 注册中心心跳发送间隔
//  "registry.reconnect.period" : 30000, // 注册中心重建连接的间隔
//  "registry.batch": false, // 是否开启有注册中心的批量注册/反注册	boolean	默认true，重连或者销毁时采用批量的方式。配为false则采取旧方式。	1.6.0
//  "registry.batch.size":	10, // 如果开启，批量的条数

//  "server.host": "0.0.0.0", // 默认绑定网卡
  "server.port.start" : 22000, // 端口段开始
  "server.port.end" : 23000, // 端口段结束
//  "server.context.path" : "/",
//  "server.ioThreads" : 0, // 默认io线程大小，推荐自动设置
//  "server.pool.type": "cached", // 默认业务线程池类型
//  "server.pool.core" : 20, // 默认业务线程池最小
//  "server.pool.max" : 200, // 默认业务线程池最大
//  "server.telnet" : true, // 是否允许telnet，针对自定义协议
//  "server.pool.queue.type" : "normal", // 默认普通业务线程池队列
//  "server.pool.queue" : 0, // 默认业务线程池队列大小
//  "server.pool.aliveTime" : 60000, //  默认业务线程池回收时间
//  "server.accepts" : 100000, // 最大支持长连接
//  "server.epoll" : false, // 是否启动epoll
//  "server.daemon" : true, // 是否hold住端口，true的话随主线程退出而退出，false的话则要主动退出


//  "service.register" : true, //默认服务是否注册
//  "service.subscribe" : true, //默认服务是否订阅

//  "provider.weight" : 100, //默认服务端权重
//  "provider.delay" : -1, // 默认发布延迟
//  "provider.include" : "*", // 默认发布方法：全部
//  "provider.exclude" : "", // 默认不发布方法
//  "provider.dynamic" : true, // 默认动态注册，false代表不主动发布
//  "provider.priority" : 0, // 接口优先级
//  "provider.invoke.timeout" : 0, //服务端调用超时， 不打断执行。0表示不判断
//  "provider.concurrents" : 0, //接口下每方法的最大可并行执行请求数，配置-1关闭并发过滤器，等于0表示开启过滤但是不限制

//  "consumer.cluster": "failover",
  "consumer.connectionHolder" : "jsf", // 默认连接全部建立长连接
//  "consumer.loadBalancer" : "random",
//  "consumer.retries" : 0, //默认失败重试次数
//  "consumer.concurrents": 0, //接口下每方法的最大可并行执行请求数，配置-1关闭并发过滤器，等于0表示开启过滤但是不限制
//  "consumer.async" : false, // 默认是否异步
//  "consumer.lazy" : false, // 默认不延迟加载
//  "consumer.sticky" : false, // 默认粘滞连接
//  "consumer.inJVM" : true, // 是否jvm内部调用（provider和consumer配置在同一个jvm内，则走本地jvm内部，不走远程）
//  "consumer.check" : false, // 是否强依赖（即没有服务节点就启动失败）
//  "consumer.oneWay" : false, // 是否单向调用（不关心结果，服务端不响应）
//  "consumer.connection" : 1, //默认长连接数
//  "consumer.connect.timeout" : 5000, //默认consumer连provider超时时间
//  "consumer.disconnect.timeout" : 10000, //默认consumer断开时等待结果的超时时间
//  "consumer.invoke.timeout" : 5000, // 默认consumer调用provider超时时间
//  "consumer.heartbeat.period" : 30000, //心跳发送间隔
//  "consumer.reconnect.period" : 10000, //重建连接间隔

//  "callback.pool.type": "cached", // 默认回调线程池类型
//  "callback.pool.core" : 10, // 默认回调线程池最小
//  "callback.pool.max" : 200, // 默认回调线程池最大
//  "callback.pool.queue" : 256, // 默认回调线程池队列
//  "callback.pool.time" : 60000, //  默认回调线程池回收时间

//  "transport.use.epoll" : false,
//  "transport.payload.max" : 8388608, //默认数据包大小 8*1024*1024
//  "transport.client.io.threads" : 0, // 客户端io线程数，默认 max(4,cpu+1)
//  "transport.client.io.ratio" : 50, // 即I/O操作和用户自定义任务的执行时间比为1：1
//  "transport.server.backlog" : 35536,
//  "transport.server.reuseAddr" : true,
//  "transport.server.keepAlive" : true,
//  "transport.server.tcpNoDelay" : true,
//  "transport.server.io.ratio" : 50,
//  "transport.server.boss.threads" : 0, // boss线程，默认max(4,cpu/2)
//  "transport.server.io.threads" : 0, // 服务端IO线程 max(8,cpu+1)
  //"transport.server.max.connection" : 65536,
  //"transport.server.telnet" : true, // 是否允许telnet
  //"transport.server.daemon" : true, // 是否守护线程，true随主线程退出而退出，false需要主动退出
//  "transport.server.dispatcher" : "", // 线程方法模型
  "transport.server.protocol.adaptive" : true, // 是否一个端口支持多协议
//  "transport.buffer.size" : 8192,
//  "transport.buffer.max" : 32768,  // 写入的buffer水位最大值
//  "transport.buffer.min" : 1024, // 写入的buffer水位最小值
//  "transport.connection.reuse":true, // 是否跨接口长链接复用

//  "compress.open" : true, // 是否开启压缩
//  "compress.size.baseline" : 2048 // 开启压缩的大小基线
    "last" : ""
}