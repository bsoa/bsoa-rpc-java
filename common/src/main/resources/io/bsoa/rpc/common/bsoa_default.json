{
  "aaa" : "ii",
  "ttt" : 1.5,
  // 默认连注册中心的超时时间
  "serialize.check.class":	false,//	序列化时是否检查父子类（声明参数和传入值是父子类）	boolean	默认true，如果业务不存在这种情况可以配置为false，提高性能	1.0.0
  "transport.consumer.epoll"	:false,//	客户端是否使用epoll（针对linux）	boolean	默认false，Linux开启epoll可提高性能	1.0.3
  "counter.batch"	:false	,//计数器服务调用步长	int	默认1，每次丢调用计数器，调大可以提高性能但会减低精准	1.2.0
  "json.serialize.fill.empty" 	:false	,//json序列化是否返回null字段。	boolean	默认false，默认只返回有属性的字段。打开会降低效率。	1.5.1
  "consumer.provider.nullable":	false,//	consumer的服务端列表是否可被清空	boolean	默认false，默认不能被清空（最后的清空请求被忽略），防止删全部节点等误操作，但是会影响列表的准确性。	1.6.0
  "invoke.send.app":	false,//	Consumer调用时是否发生信息	boolean	默认true，服务端拿到调用端的自动部署应用信息。配为false，服务端拿不到调用者信息	1.6.0
  "serialize.check.reference"	:false,//	序列化是否检测循环引用类型	string	默认true，针对c++等调用者进行关闭	1.6.0
  "json.serializer.features":	false,//	json序列化的时候，开启的特性	string	默认空，参见com.jd.fastjson.serializer.SerializerFeature，多个逗号分隔	1.6.0
  "json.parser.features":	false,//	json解析的时候，开启的特性	string	默认空，参见com.jd.fastjson.parser.Feature，多个逗号分隔	1.6.0


  "transport.heart.io" : true, // 心跳在IO线程吗？ TODO
  "transport.negotiator.async" : false, // 协商请求在IO线程执行吗？ TODO



  "extension.load.path" : ["META-INF/bsoa/", "META-INF/services/"], // 扩展点加载的路径

  "default.protocol" : "bsoa",
  "default.serialization" : "hessian",
  "default.compress" : "snappy",
  "default.proxy" : "javassist",
  "default.charset" : "UTF-8",
  "default.transport" : "netty4",

  //  ==============配置相关============
  "registry.connect.timeout" : 20000,   /* 默认连注册中心的超时时间*/
  "registry.register.batch":	 false,//	是否开启有注册中心的批量注册/反注册	boolean	默认true，重连或者销毁时采用批量的方式。配为false则采取旧方式。	1.6.0

  "server.port.start" : 22000, // 端口段开始
  "server.port.end" : 23000, // 端口段结束
  "server.context.path" : "/",
  "server.pool.type": "cached", // 默认业务线程池类型
  "server.pool.core" : 20, // 默认业务线程池最小
  "server.pool.max" : 200, // 默认业务线程池最大
  "server.pool.queue.type" : "normal", // 默认普通业务线程池队列
  "server.pool.queue" : 0, // 默认业务线程池队列大小
  "server.pool.time" : 60000, //  默认业务线程池回收时间

  "provider.weight" : 100, //默认服务端权重
  "provider.delay" : -1, // 默认发布延迟

  "consumer.retries" : 0, //默认失败重试次数
  "consumer.connection.num" : 1, //默认长连接数
  "consumer.heartbeat.period" : 30000, //心跳发送间隔
  "consumer.reconnect.period" : 30000, //心跳发送间隔
  "consumer.share.reconnect.thread" : false, //是否所有客户端共享一个重连线程

  "client.connect.timeout" : 5000, //默认consumer连provider超时时间
  "client.disconnect.timeout" : 10000, //默认consumer断开时等待结果的超时时间
  "client.invoke.timeout" : 5000, // 默认consumer调用provider超时时间

  "callback.pool.type": "cached", // 默认回调线程池类型
  "callback.pool.core" : 10, // 默认回调线程池最小
  "callback.pool.max" : 200, // 默认回调线程池最大
  "callback.pool.queue" : 0, // 默认回调线程池队列
  "callback.pool.time" : 60000, //  默认回调线程池回收时间

  "transport.use.epoll" : false,
  "transport.payload.max" : 8388608, //默认数据包大小 8*1024*1024
  "transport.client.io.threads" : 0, // 客户端io线程数，默认 max(4,cpu+1)
  "transport.client.io.ratio" : 50, // 即I/O操作和用户自定义任务的执行时间比为1：1
  "transport.server.backlog" : 35536,
  "transport.server.reuseAddr" : true,
  "transport.server.keepAlive" : true,
  "transport.server.tcpNoDelay" : true,
  "transport.server.io.ratio" : 50,
  "transport.server.boss.threads" : 0, // boss线程，默认max(4,cpu/2)
  "transport.server.io.threads" : 0, // 服务端IO线程 max(8,cpu+1)
  "transport.server.max.connection" : 65536,
  "transport.server.telnet" : true, // 是否允许telnet
  "transport.server.daemon" : true, // 是否守护线程，true随主线程退出而退出，false需要主动退出
  "transport.server.dispatcher" : "", // 线程方法模型
  "transport.server.protocol.adaptive" : false, // 是否一个端口支持多协议
  "transport.buffer.size" : 8192,
  "transport.buffer.max" : 32768,
  "transport.buffer.min" : 1024,
  "transport.connection.reuse":true // 是否跨接口长链接复用

  //adadad
}